<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Instagram Grid Editor</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    .grid-cell {
      aspect-ratio: 9/16;
      background-size: cover;
      background-position: center;
      position: relative;
      overflow: hidden;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .grid-cell:hover {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    }

    .grid-cell.dragging {
      opacity: 0.5;
      border: 2px dashed #0095f6;
    }

    .color-option {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
      margin: 4px;
    }

    .color-option:hover,
    .color-option.active {
      border-color: #0095f6;
    }

    #exportBtn {
      background-color: #0095f6;
    }

    #exportBtn:hover {
      background-color: #0081d6;
    }

    .empty-cell-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      color: #8e8e8e;
      font-size: 14px;
      pointer-events: none;
    }

    .empty-cell-bg {
      background-color: #fafafa;
    }

    .cell-content {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .color-fill-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      mix-blend-mode: multiply;
    }

    .cell-controls {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.5);
      padding: 8px;
      display: flex;
      justify-content: center;
      gap: 8px;
      z-index: 2;
      opacity: 0;
      border-bottom-left-radius: 8px;
      border-bottom-right-radius: 8px;
    }

    .grid-cell:hover .cell-controls {
      opacity: 1;
    }

    .control-btn {
      background: rgba(255, 255, 255, 0.9);
      border: none;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 14px;
      color: #262626;
    }

    .control-btn:hover {
      background: white;
    }

    .color-palette {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 8px;
      padding: 12px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      border: 1px solid #dbdbdb;
    }

    .color-picker-container {
      position: relative;
    }

    .color-picker-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      z-index: 100;
      margin-top: 8px;
      display: none;
      min-width: 240px;
    }

    .color-picker-container.active .color-picker-dropdown {
      display: block;
    }

    .custom-color-section {
      padding: 12px;
      background: white;
      border-top: 1px solid #dbdbdb;
      border-radius: 0 0 12px 12px;
    }

    .custom-color-input {
      width: 100%;
      height: 36px;
      border: 1px solid #dbdbdb;
      border-radius: 8px;
      padding: 4px;
      margin-bottom: 8px;
    }

    .hex-color-input {
      width: 100%;
      height: 36px;
      border: 1px solid #dbdbdb;
      border-radius: 8px;
      padding: 4px 8px;
      margin-bottom: 8px;
      font-family: monospace;
    }

    .apply-custom-color {
      width: 100%;
      background-color: #0095f6;
      color: white;
      border: none;
      border-radius: 8px;
      padding: 8px;
      font-weight: 600;
      cursor: pointer;
    }

    .apply-custom-color:hover {
      background-color: #0081d6;
    }

    .selected-color-display {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 2px solid #dbdbdb;
      margin-right: 8px;
    }

    .selected-color-display:hover {
      border-color: #0095f6;
    }

    .upload-button {
      background-color: #0095f6;
      color: white;
      border: none;
      border-radius: 8px;
      padding: 8px 16px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .upload-button:hover {
      background-color: #0081d6;
    }

    .upload-progress {
      margin-top: 12px;
      background-color: #f0f0f0;
      border-radius: 8px;
      overflow: hidden;
    }

    .progress-bar {
      height: 4px;
      background-color: #0095f6;
    }

    .upload-status {
      margin-top: 8px;
      font-size: 14px;
      color: #8e8e8e;
    }

    /* Theme styles */
    body.dark-theme {
      background-color: #121212;
      color: #ffffff;
    }

    body.dark-theme .container {
      background-color: #1e1e1e;
    }

    body.dark-theme .grid-cell {
      background-color: #2d2d2d;
    }

    body.dark-theme .empty-cell-bg {
      background-color: #2d2d2d;
    }

    body.dark-theme .empty-cell-content {
      color: #8e8e8e;
    }

    body.dark-theme .color-palette {
      background-color: #2d2d2d;
      border-color: #404040;
    }

    body.dark-theme .custom-color-section {
      background-color: #2d2d2d;
      border-color: #404040;
    }

    body.dark-theme .custom-color-input,
    body.dark-theme .hex-color-input {
      background-color: #404040;
      border-color: #505050;
      color: #ffffff;
    }

    body.dark-theme .upload-progress {
      background-color: #404040;
    }

    body.dark-theme .mb-6 {
      background-color: #2d2d2d;
      border-color: #404040;
    }

    body.dark-theme .text-gray-700 {
      color: #e0e0e0;
    }

    body.dark-theme .text-gray-600 {
      color: #b0b0b0;
    }

    body.dark-theme .bg-white {
      background-color: #2d2d2d;
    }

    body.dark-theme .border-gray-200 {
      border-color: #404040;
    }

    body.dark-theme .bg-gray-50 {
      background-color: #2d2d2d;
    }

    body.dark-theme .text-gray-800 {
      color: #ffffff;
    }

    body.dark-theme .bg-gray-100 {
      background-color: #404040;
    }

    body.dark-theme .hover\:bg-gray-200:hover {
      background-color: #505050;
    }

    body.dark-theme .hover\:bg-gray-50:hover {
      background-color: #404040;
    }

    .theme-switch {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
    }

    .theme-switch-btn {
      background-color: #0095f6;
      color: white;
      border: none;
      border-radius: 8px;
      padding: 8px 16px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .theme-switch-btn:hover {
      background-color: #0081d6;
    }
  </style>
</head>

<body class="bg-white font-sans">
  <div class="container mx-auto px-4 py-8 max-w-4xl">
    <header class="flex justify-between items-center mb-8">
      <h1 class="text-2xl font-bold text-gray-800">Instagram Grid Editor</h1>
      <div class="flex space-x-4">
        <button id="addRowBtn" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg flex items-center">
          <i class="fas fa-plus mr-2"></i> Add Row
        </button>
        <button id="exportBtn"
          class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-lg flex items-center">
          <i class="fas fa-download mr-2"></i> Export JPEG
        </button>
      </div>
    </header>

    <div class="theme-switch">
      <button class="theme-switch-btn" onclick="toggleTheme()">
        <i class="fas fa-moon"></i>
        <span>Dark Mode</span>
      </button>
    </div>

    <div class="mb-6 p-4 bg-white rounded-lg border border-gray-200">
      <div class="flex flex-wrap items-center gap-6">
        <div>
          <label for="imageUpload" class="block text-sm font-medium text-gray-700 mb-2">Upload Images</label>
          <input type="file" id="imageUpload" accept="image/*" multiple class="hidden">
          <button onclick="document.getElementById('imageUpload').click()" class="upload-button">
            <i class="fas fa-image"></i>
            <span>Select Files</span>
          </button>
          <div id="uploadProgress" class="hidden">
            <div class="upload-progress">
              <div id="progressBar" class="progress-bar" style="width: 0%"></div>
            </div>
            <p id="uploadStatus" class="upload-status">Processing...</p>
          </div>
        </div>

        <div class="color-picker-container">
          <label class="block text-sm font-medium text-gray-700 mb-2">Selected Color</label>
          <div class="flex items-center">
            <div id="selectedColorDisplay" class="selected-color-display" style="background-color: #ffffff;" onclick="toggleColorPicker()"></div>
            <span class="text-sm text-gray-600">Click to change color</span>
          </div>

          <div class="color-picker-dropdown">
            <div class="color-palette">
              <div class="color-option bg-red-500" data-color="#ff0000" onclick="selectColor(this)"></div>
              <div class="color-option bg-orange-500" data-color="#ff7f00" onclick="selectColor(this)"></div>
              <div class="color-option bg-yellow-500" data-color="#ffff00" onclick="selectColor(this)"></div>
              <div class="color-option bg-green-500" data-color="#00ff00" onclick="selectColor(this)"></div>
              <div class="color-option bg-blue-500" data-color="#0000ff" onclick="selectColor(this)"></div>
              <div class="color-option bg-purple-500" data-color="#8b00ff" onclick="selectColor(this)"></div>
              <div class="color-option bg-pink-500" data-color="#ff00ff" onclick="selectColor(this)"></div>
              <div class="color-option bg-rose-500" data-color="#ff007f" onclick="selectColor(this)"></div>
              <div class="color-option bg-amber-500" data-color="#ffbf00" onclick="selectColor(this)"></div>
              <div class="color-option bg-lime-500" data-color="#7fff00" onclick="selectColor(this)"></div>
              <div class="color-option bg-emerald-500" data-color="#00ff7f" onclick="selectColor(this)"></div>
              <div class="color-option bg-cyan-500" data-color="#00ffff" onclick="selectColor(this)"></div>
              <div class="color-option bg-sky-500" data-color="#007fff" onclick="selectColor(this)"></div>
              <div class="color-option bg-violet-500" data-color="#7f00ff" onclick="selectColor(this)"></div>
              <div class="color-option bg-fuchsia-500" data-color="#ff007f" onclick="selectColor(this)"></div>
              <div class="color-option bg-gray-500" data-color="#808080" onclick="selectColor(this)"></div>
              <div class="color-option bg-slate-500" data-color="#708090" onclick="selectColor(this)"></div>
              <div class="color-option bg-black" data-color="#000000" onclick="selectColor(this)"></div>
              <div class="color-option bg-white border border-gray-300 active" data-color="#ffffff" onclick="selectColor(this)"></div>
            </div>
            <div class="custom-color-section">
              <input type="color" id="customColorPicker" class="custom-color-input" value="#ffffff">
              <input type="text" id="hexColorInput" class="hex-color-input" placeholder="Enter hex color (e.g. #ff0000)">
              <button id="applyCustomColor" class="apply-custom-color">
                Apply Custom Color
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="gridContainer" class="grid grid-cols-3 gap-4 mb-8">
      <!-- Grid cells will be added here -->
    </div>

    <div class="text-center">
      <button id="loadMoreBtn" class="bg-gray-100 hover:bg-gray-200 text-gray-700 px-4 py-2 rounded-lg">
        <i class="fas fa-arrow-down mr-2"></i> Load More
      </button>
    </div>
  </div>

  <script>
    // Initialize the grid
    let gridData = [];
    let draggedCell = null;
    // Initialize with a default selected color (white)
    let selectedColor = '#ffffff';

    // Load saved data from localStorage
    function loadFromStorage() {
      const savedData = localStorage.getItem('instagramGridData');
      if (savedData) {
        gridData = JSON.parse(savedData);
        // Ensure backward compatibility if old data exists without 'type'
         gridData = gridData.map(cell => {
             if (cell && cell.content && !cell.type) {
                 return { type: 'image', content: cell.content, color: null };
             } else if (!cell || (!cell.content && !cell.color)) {
                 return { type: 'empty', content: null, color: null };
             }
             return cell; // Already has type
         });
        renderGrid();
      } else {
        // Initialize with 3 empty rows if no saved data
        addNewRow();
        addNewRow();
        addNewRow();
      }
      // Set the display for the default selected color
      document.getElementById('selectedColorDisplay').style.backgroundColor = selectedColor;
      // Mark the default color option as active
      document.querySelector('.color-option[data-color="#ffffff"]').classList.add('active');
    }

    // Save current grid to localStorage
    function saveToStorage() {
      localStorage.setItem('instagramGridData', JSON.stringify(gridData));
    }

    // Add a new row to the grid
    function addNewRow() {
      for (let i = 0; i < 3; i++) {
        gridData.push({type: 'empty', content: null, color: null});
      }
      renderGrid();
      saveToStorage();
    }

    // Render the entire grid
    function renderGrid() {
      const gridContainer = document.getElementById('gridContainer');
      gridContainer.innerHTML = '';

      gridData.forEach((cell, index) => {
        const cellElement = document.createElement('div');
        cellElement.className = 'grid-cell rounded-lg overflow-hidden relative'; // Base classes
        cellElement.dataset.index = index;

        if (cell.type === 'image') {
          cellElement.innerHTML = `
                        <img src="${cell.content}" class="cell-content">
                        ${cell.color ? `<div class="color-fill-overlay" style="background-color: ${cell.color};"></div>` : ''}
                        <div class="cell-controls">
                             <button class="control-btn" title="Apply selected color overlay" onclick="event.stopPropagation(); applyColorToCell(${index}, selectedColor)">
                                <i class="fas fa-fill-drip"></i>
                            </button>
                            <button class="control-btn" title="Remove image" onclick="event.stopPropagation(); clearCell(${index})">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    `;
        } else if (cell.type === 'color') {
          cellElement.style.backgroundColor = cell.content;
           cellElement.innerHTML = `
                        <div class="cell-controls">
                             <!-- Fill button on color cell might not be needed, or could change color -->
                             <!-- <button class="control-btn" title="Change color" onclick="event.stopPropagation(); applyColorToCell(${index}, selectedColor)">
                                <i class="fas fa-fill-drip"></i>
                            </button> -->
                            <button class="control-btn" title="Remove color" onclick="event.stopPropagation(); clearCell(${index})">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    `;
        } else { // type is 'empty'
          cellElement.classList.add('empty-cell-bg'); // Add a background class
          cellElement.innerHTML = `
                         <div class="empty-cell-content">
                             <i class="fas fa-image text-2xl mb-2 text-gray-400"></i>
                             <p class="text-gray-500">Empty</p>
                         </div>
                        <div class="cell-controls">
                            <button class="control-btn" title="Fill with selected color" onclick="event.stopPropagation(); applyColorToCell(${index}, selectedColor)">
                                <i class="fas fa-fill-drip"></i>
                            </button>
                            <button class="control-btn" title="Clear cell" onclick="event.stopPropagation(); clearCell(${index})">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    `;
           // Add click handler specifically for empty cells to allow image upload
           // This handler is on the cellElement itself, but stopPropagation on control buttons prevents it from firing when controls are clicked.
           cellElement.addEventListener('click', function() {
                // Only trigger image upload if it's currently empty
                if (gridData[index].type === 'empty') {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'image/*';
                    input.onchange = (e) => {
                        if (e.target.files.length) {
                            handleImageUpload(e.target.files[0], index);
                        }
                    };
                    input.click();
                }
           });
        }


        // Add drag and drop events to ALL cells
        cellElement.draggable = true;
        cellElement.addEventListener('dragstart', handleDragStart);
        cellElement.addEventListener('dragover', handleDragOver);
        cellElement.addEventListener('drop', handleDrop);
        cellElement.addEventListener('dragend', handleDragEnd);


        gridContainer.appendChild(cellElement);
      });
    }

    // Handle image upload with Instagram aspect ratio
    function handleImageUpload(file, index) {
      // Show progress indicator
      document.getElementById('uploadProgress').classList.remove('hidden');
      document.getElementById('progressBar').style.width = '0%';
      document.getElementById('uploadStatus').textContent = 'Processing...';

      // Check file size (max 10MB)
      if (file.size > 10 * 1024 * 1024) {
        document.getElementById('uploadStatus').textContent = 'File too large (max 10MB)';
        document.getElementById('progressBar').style.width = '100%';
        setTimeout(() => {
          document.getElementById('uploadProgress').classList.add('hidden');
        }, 3000);
        return;
      }

      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = function () {
          // Create canvas to crop to 9:16 ratio
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');

          // Instagram ratio is typically 4:5 to 9:16. 9:16 is portrait video.
          const targetWidth = 1080;
          const targetHeight = 1920;
          const targetRatio = targetWidth / targetHeight;

          let sourceX = 0, sourceY = 0;
          let sourceWidth = img.width, sourceHeight = img.height;

          const sourceRatio = img.width / img.height;

          // Calculate source area to crop
          if (sourceRatio > targetRatio) {
            // Source is wider, crop sides
            sourceWidth = img.height * targetRatio;
            sourceX = (img.width - sourceWidth) / 2;
          } else {
            // Source is taller or same ratio, crop top/bottom
            sourceHeight = img.width / targetRatio;
            sourceY = (img.height - sourceHeight) / 2;
          }

          canvas.width = targetWidth;
          canvas.height = targetHeight;

          // Draw the cropped portion onto the canvas, scaled to target size
          ctx.drawImage(
            img,
            sourceX, sourceY, sourceWidth, sourceHeight,
            0, 0, canvas.width, canvas.height
          );

          // Update progress
          document.getElementById('progressBar').style.width = '50%';
          document.getElementById('uploadStatus').textContent = 'Optimizing image...';

          // Optimize image quality based on file size
          const quality = file.size > 5 * 1024 * 1024 ? 0.8 : 0.9;
          const croppedImage = canvas.toDataURL('image/jpeg', quality);

          // Check if index is valid
          if (index >= 0 && index < gridData.length) {
            gridData[index] = {
              type: 'image',
              content: croppedImage,
              color: null
            };
            renderGrid();
            saveToStorage();

            // Update progress
            document.getElementById('progressBar').style.width = '100%';
            document.getElementById('uploadStatus').textContent = 'Upload complete!';
            setTimeout(() => {
              document.getElementById('uploadProgress').classList.add('hidden');
            }, 2000);
          } else {
            console.error("Attempted to upload image to invalid index:", index);
            document.getElementById('uploadStatus').textContent = 'Error: Invalid cell index';
            setTimeout(() => {
              document.getElementById('uploadProgress').classList.add('hidden');
            }, 3000);
          }
        };
        img.onerror = function() {
          document.getElementById('uploadStatus').textContent = 'Error: Failed to load image';
          setTimeout(() => {
            document.getElementById('uploadProgress').classList.add('hidden');
          }, 3000);
        };
        img.src = e.target.result;
      };
      reader.onerror = function() {
        document.getElementById('uploadStatus').textContent = 'Error: Failed to read file';
        setTimeout(() => {
          document.getElementById('uploadProgress').classList.add('hidden');
        }, 3000);
      };
      reader.readAsDataURL(file);
    }

    // Handle multiple image upload
    document.getElementById('imageUpload').addEventListener('change', (e) => {
      const files = Array.from(e.target.files);
      let emptyCellIndices = gridData
          .map((cell, idx) => cell.type === 'empty' ? idx : -1)
          .filter(idx => idx !== -1);

      // If there aren't enough empty cells, add rows
      if (files.length > emptyCellIndices.length) {
        const neededRows = Math.ceil((files.length - emptyCellIndices.length) / 3);
        for (let i = 0; i < neededRows; i++) {
          addNewRow();
        }
        // Re-calculate empty indices after adding rows and rendering
        emptyCellIndices = gridData
          .map((cell, idx) => cell.type === 'empty' ? idx : -1)
          .filter(idx => idx !== -1);
      }

      // Process files sequentially to avoid overwhelming the browser
      let currentIndex = 0;
      const processNextFile = () => {
        if (currentIndex < files.length && currentIndex < emptyCellIndices.length) {
          handleImageUpload(files[currentIndex], emptyCellIndices[currentIndex]);
          currentIndex++;
          // Process next file after a short delay to allow UI updates
          setTimeout(processNextFile, 100);
        }
      };
      processNextFile();

      // Reset input
      e.target.value = '';
    });

    // Color picker toggle function
    function toggleColorPicker() {
      const container = document.querySelector('.color-picker-container');
      container.classList.toggle('active');
    }

    // Close color picker when clicking outside
    document.addEventListener('click', function(event) {
      const colorPicker = document.querySelector('.color-picker-container');
      if (!colorPicker.contains(event.target)) {
        colorPicker.classList.remove('active');
      }
    });

    // Color selection functions
    function selectColor(element) {
      // Remove active class from all color options
      document.querySelectorAll('.color-palette .color-option').forEach(opt => {
        opt.classList.remove('active');
      });

      // Add active class to selected color
      element.classList.add('active');

      // Get the color from data attribute or background
      const color = element.dataset.color || element.style.backgroundColor;

      selectedColor = color;

      // Update selected color display
      document.getElementById('selectedColorDisplay').style.backgroundColor = selectedColor;
    }

    // Apply custom color from color picker input
    document.getElementById('applyCustomColor').addEventListener('click', () => {
      const customColorInput = document.getElementById('customColorPicker');
      const customColor = customColorInput.value;

      // Remove active class from predefined color options
      document.querySelectorAll('.color-palette .color-option').forEach(opt => {
        opt.classList.remove('active');
      });

      selectedColor = customColor;
      document.getElementById('selectedColorDisplay').style.backgroundColor = selectedColor;
    });

    // Function to apply color to a specific cell index
    // This is called from the control buttons on cells
    function applyColorToCell(index, color) {
      if (index >= 0 && index < gridData.length) {
          if (gridData[index].type === 'image') {
            // Apply as overlay to image
            gridData[index].color = color;
          } else if (gridData[index].type === 'empty') {
            // Change type to color fill
            gridData[index] = {type: 'color', content: color, color: null}; // content holds the color string
          }
          // If type is 'color', we could potentially change its color here too,
          // but the current UI only shows the fill icon on image/empty.
          // If we added it to color cells, add 'else if (gridData[index].type === 'color') { gridData[index].content = color; }'

          renderGrid();
          saveToStorage();
      } else {
          console.error("Attempted to apply color to invalid index:", index);
      }
    }

    // Clear a cell (makes it empty)
    function clearCell(index) {
       if (index >= 0 && index < gridData.length) {
           gridData[index] = {type: 'empty', content: null, color: null};
           renderGrid();
           saveToStorage();
       } else {
           console.error("Attempted to clear invalid index:", index);
       }
    }

    // Drag and drop functions
    function handleDragStart(e) {
      draggedCell = this;
      this.classList.add('dragging');
      e.dataTransfer.setData('text/plain', this.dataset.index);
      e.dataTransfer.effectAllowed = 'move';
       // Add a timeout to allow the ghost image to be created before hiding the original
        setTimeout(() => {
             this.style.visibility = 'hidden';
        }, 0);
    }

    function handleDragOver(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
       // Add visual indicator to drop target if needed
        // this.classList.add('drag-over');
    }

    function handleDrop(e) {
      e.preventDefault();
      // this.classList.remove('drag-over'); // Remove visual indicator
      const sourceIndex = parseInt(e.dataTransfer.getData('text/plain'));
      const targetIndex = parseInt(this.dataset.index);

      if (sourceIndex !== targetIndex) {
        // Swap the cells data in the array
        const temp = gridData[sourceIndex];
        gridData[sourceIndex] = gridData[targetIndex];
        gridData[targetIndex] = temp;

        renderGrid(); // Re-render the grid
        saveToStorage(); // Save the new order
      }
    }

    function handleDragEnd() {
      this.classList.remove('dragging');
       // Make the original element visible again after the drag finishes
       if(draggedCell) {
            draggedCell.style.visibility = '';
       }
      draggedCell = null;
       // Remove drag-over class from all cells (in case drop didn't happen on a cell)
       document.querySelectorAll('.grid-cell').forEach(cell => cell.classList.remove('drag-over'));
    }

    // Export last 9 images as JPEG
    document.getElementById('exportBtn').addEventListener('click', () => {
      // Filter cells that are either images (with or without overlay) or solid colors
      const cellsToExport = gridData.filter(cell => cell.type === 'image' || cell.type === 'color');

      if (cellsToExport.length === 0) {
        alert('Add images or colored cells to export!');
        return;
      }

      // Take last 9 cells (or all if less than 9)
      const items = cellsToExport.slice(-9);

      // Create a canvas for the grid
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      // Target dimensions for each cell (Instagram standard might be 1080x1080, or 1080x1350, 1080x1920)
      // Since the grid cells are 9:16, let's use a size that reflects that but is reasonable for export.
      // A common export size for a 3x3 grid might make sense, perhaps 1080px width total (3x 360px wide cells)
      // If cells are 9:16 (width:height), then height = width * 16/9.
      // Let's use cell size 300x533 (approx 9:16) which results in a 900x1599 grid. Or scale up.
      // Using 360x640 as cell size -> 1080x1920 total for 3x3 block. This matches a common tall Insta post.
      const cellWidth = 360;
      const cellHeight = 640; // 360 * (16/9) = 640

      // Calculate canvas size based on number of items (max 3 columns)
      const cols = Math.min(items.length, 3);
      const rows = Math.ceil(items.length / 3);

      canvas.width = cols * cellWidth;
      canvas.height = rows * cellHeight;

      // Draw white background
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Load and draw each item (image or color)
      let itemsLoaded = 0; // Counter for images, colors are synchronous
      const totalImages = items.filter(item => item.type === 'image').length;

      if (totalImages === 0) {
           // If no images, just draw colors and export immediately
           items.forEach((item, index) => {
                const col = index % 3;
                const row = Math.floor(index / 3);
                const x = col * cellWidth;
                const y = row * cellHeight;

                if (item.type === 'color') {
                   ctx.fillStyle = item.content;
                   ctx.fillRect(x, y, cellWidth, cellHeight);
                }
                // Image type is filtered out if totalImages is 0
           });
           const dataURL = canvas.toDataURL('image/jpeg', 0.95); // Use higher quality for final export
           const link = document.createElement('a');
           link.download = 'instagram-grid.jpg';
           link.href = dataURL;
           link.click();

      } else {
         // If there are images, load them asynchronously
         items.forEach((item, index) => {
            const col = index % 3;
            const row = Math.floor(index / 3);
            const x = col * cellWidth;
            const y = row * cellHeight;

            if (item.type === 'color') {
               ctx.fillStyle = item.content;
               ctx.fillRect(x, y, cellWidth, cellHeight);
               // Color blocks are synchronous, increment counter here if needed for a single counter
                if (totalImages === 0) itemsLoaded++; // Only if no images are expected
            } else if (item.type === 'image') {
                const img = new Image();
                img.onload = function () {
                   // Draw image scaled to cell size
                   ctx.drawImage(img, x, y, cellWidth, cellHeight);

                   // Apply color overlay if exists
                   if (item.color) {
                     ctx.save();
                     ctx.globalCompositeOperation = 'multiply';
                     ctx.fillStyle = item.color;
                     ctx.fillRect(x, y, cellWidth, cellHeight);
                     ctx.restore();
                   }

                   itemsLoaded++;
                   // Check if all images are loaded (only count images for async completion)
                   if (itemsLoaded === totalImages) {
                     // All async tasks (image loading) are done, export canvas
                     const dataURL = canvas.toDataURL('image/jpeg', 0.95); // Use higher quality
                     const link = document.createElement('a');
                     link.download = 'instagram-grid.jpg';
                     link.href = dataURL;
                     link.click();
                   }
                };
                img.onerror = function() {
                     console.error("Failed to load image for export:", item.content);
                     itemsLoaded++; // Still increment counter to allow export to proceed
                     if (itemsLoaded === totalImages) {
                        // Export even if some images failed
                         const dataURL = canvas.toDataURL('image/jpeg', 0.95); // Use higher quality
                         const link = document.createElement('a');
                         link.download = 'instagram-grid.jpg';
                         link.href = dataURL;
                         link.click();
                     }
                };
                img.src = item.content;
            }
         });
      }
    });

    // Button event listeners
    document.getElementById('addRowBtn').addEventListener('click', addNewRow);
    document.getElementById('loadMoreBtn').addEventListener('click', addNewRow);

     // Keep color picker dropdown open when interacting inside it
     document.querySelector('.color-picker-dropdown').addEventListener('mouseenter', () => {
         document.querySelector('.color-picker-container').classList.add('active');
     });
     document.querySelector('.color-picker-dropdown').addEventListener('mouseleave', () => {
         document.querySelector('.color-picker-container').classList.remove('active');
     });

    // Theme switching
    function toggleTheme() {
      document.body.classList.toggle('dark-theme');
      const isDark = document.body.classList.contains('dark-theme');
      localStorage.setItem('theme', isDark ? 'dark' : 'light');
      
      const themeBtn = document.querySelector('.theme-switch-btn');
      themeBtn.innerHTML = isDark 
        ? '<i class="fas fa-sun"></i><span>Light Mode</span>'
        : '<i class="fas fa-moon"></i><span>Dark Mode</span>';
    }

    // Load saved theme
    function loadTheme() {
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme === 'dark') {
        document.body.classList.add('dark-theme');
        const themeBtn = document.querySelector('.theme-switch-btn');
        themeBtn.innerHTML = '<i class="fas fa-sun"></i><span>Light Mode</span>';
      }
    }

    // Hex color input handling
    document.getElementById('hexColorInput').addEventListener('input', function(e) {
      const hexColor = e.target.value;
      if (/^#[0-9A-Fa-f]{6}$/.test(hexColor)) {
        document.getElementById('customColorPicker').value = hexColor;
        selectedColor = hexColor;
        document.getElementById('selectedColorDisplay').style.backgroundColor = hexColor;
      }
    });

    // Update hex input when color picker changes
    document.getElementById('customColorPicker').addEventListener('input', function(e) {
      document.getElementById('hexColorInput').value = e.target.value;
    });

    // Initialize theme
    document.addEventListener('DOMContentLoaded', function() {
      loadTheme();
      loadFromStorage();
    });
  </script>
</body>

</html>