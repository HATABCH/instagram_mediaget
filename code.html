<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Instagram Grid Editor</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    /* Keep your existing styles */
    .grid-cell {
      aspect-ratio: 9/16;
      background-size: cover;
      background-position: center;
      position: relative;
      overflow: hidden;
      border-radius: 8px;
      /* Smaller radius to fit better in grid preview */
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
      /* Lighter shadow for grid */
    }

    .grid-cell:hover {
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      /* Lighter hover shadow */
    }

    .grid-cell.dragging {
      opacity: 0.5;
      border: 2px dashed #0095f6;
    }

    .color-option {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
      margin: 4px;
    }

    .color-option:hover,
    .color-option.active {
      border-color: #0095f6;
    }

    #exportBtn {
      background-color: #28a745;
      /* Green for export */
    }

    #exportBtn:hover {
      background-color: #218838;
    }

    #addRowBtn {
      background-color: #007bff;
      /* Blue for add row */
    }

    #addRowBtn:hover {
      background-color: #0056b3;
    }


    .empty-cell-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      color: #8e8e8e;
      font-size: 14px;
      pointer-events: none;
      /* Don't interfere with click handler on parent */
    }

    .empty-cell-bg {
      background-color: #fafafa;
    }

    .cell-content {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .color-fill-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      mix-blend-mode: multiply;
      /* Standard Instagram effect */
      pointer-events: none;
      /* Allow clicks to pass through to controls/cell */
    }

    .cell-controls {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.5);
      padding: 8px;
      display: flex;
      justify-content: center;
      gap: 8px;
      z-index: 2;
      opacity: 0;
      /* Inherit rounded corners from cell */
      border-bottom-left-radius: 8px;
      border-bottom-right-radius: 8px;
      transition: opacity 0.2s ease-in-out;
      /* Smooth fade */
    }

    .grid-cell:hover .cell-controls {
      opacity: 1;
    }

    .control-btn {
      background: rgba(255, 255, 255, 0.9);
      border: none;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 14px;
      color: #262626;
      transition: background-color 0.1s ease-in-out;
    }

    .control-btn:hover {
      background: white;
    }

    .color-palette {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 8px;
      padding: 12px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      border: 1px solid #dbdbdb;
    }

    .color-picker-container {
      position: relative;
    }

    .color-picker-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      z-index: 100;
      margin-top: 8px;
      display: none;
      min-width: 240px;
      /* Prevent background from showing through rounded corners */
      overflow: hidden;
      border-radius: 12px;
      /* Match palette border radius */
    }

    .color-picker-container.active .color-picker-dropdown {
      display: block;
    }

    .custom-color-section {
      padding: 12px;
      background: white;
      border-top: 1px solid #dbdbdb;
      /* Remove bottom radius as it's on the container */
      /* border-radius: 0 0 12px 12px; */
    }

    .custom-color-input {
      /* Hide default color input */
      position: absolute;
      left: -9999px;
    }

    /* Style the clickable area for custom color */
    .custom-color-trigger {
      display: flex;
      align-items: center;
      gap: 8px;
      border: 1px solid #dbdbdb;
      border-radius: 8px;
      padding: 8px 12px;
      cursor: pointer;
      margin-bottom: 8px;
      background-color: #f9f9f9;
    }

    .hex-color-input {
      width: 100%;
      height: 36px;
      border: 1px solid #dbdbdb;
      border-radius: 8px;
      padding: 4px 8px;
      margin-bottom: 8px;
      font-family: monospace;
    }

    .apply-custom-color {
      width: 100%;
      background-color: #0095f6;
      color: white;
      border: none;
      border-radius: 8px;
      padding: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.2s ease-in-out;
    }

    .apply-custom-color:hover {
      background-color: #0081d6;
    }

    .selected-color-display {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 2px solid #dbdbdb;
      margin-right: 8px;
      cursor: pointer;
      /* Make the display itself clickable to open picker */
      transition: border-color 0.2s ease-in-out;
    }

    .selected-color-display:hover {
      border-color: #0095f6;
    }

    .upload-button {
      background-color: #0095f6;
      color: white;
      border: none;
      border-radius: 8px;
      padding: 8px 16px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: background-color 0.2s ease-in-out;
    }

    .upload-button:hover {
      background-color: #0081d6;
    }

    .upload-progress {
      margin-top: 12px;
      background-color: #f0f0f0;
      border-radius: 8px;
      overflow: hidden;
    }

    .progress-bar {
      height: 4px;
      background-color: #0095f6;
      transition: width 0.3s ease-in-out;
    }

    .upload-status {
      margin-top: 8px;
      font-size: 14px;
      color: #8e8e8e;
    }

    /* Theme styles */
    body.dark-theme {
      background-color: #121212;
      color: #ffffff;
    }

    body.dark-theme .container {
      background-color: #1e1e1e;
    }

    body.dark-theme .grid-cell {
      background-color: #2d2d2d;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
    }

    body.dark-theme .grid-cell:hover {
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);
    }


    body.dark-theme .empty-cell-bg {
      background-color: #2d2d2d;
    }

    body.dark-theme .empty-cell-content {
      color: #8e8e8e;
    }

    body.dark-theme .color-palette {
      background-color: #2d2d2d;
      border-color: #404040;
    }

    body.dark-theme .custom-color-section {
      background-color: #2d2d2d;
      border-color: #404040;
    }

    body.dark-theme .custom-color-trigger {
      background-color: #3d3d3d;
      border-color: #505050;
      color: #ffffff;
    }

    body.dark-theme .hex-color-input {
      background-color: #404040;
      border-color: #505050;
      color: #ffffff;
    }

    body.dark-theme .upload-progress {
      background-color: #404040;
    }

    /* Adjust dark mode styles for new profile elements */
    body.dark-theme .profile-header {
      /* No specific background, inherits from container */
    }

    body.dark-theme #username,
    body.dark-theme #bio,
    body.dark-theme .text-gray-800

    /* used in profile info */
      {
      color: #ffffff;
    }

    body.dark-theme .text-gray-700

    /* used in stats */
      {
      color: #e0e0e0;
    }

    body.dark-theme .border-gray-300

    /* avatar border */
      {
      border-color: #404040;
    }

    body.dark-theme .border-gray-200 {
      border-color: #404040;
    }

    body.dark-theme .text-gray-500

    /* tab inactive color */
      {
      color: #8e8e8e;
    }

    body.dark-theme .border-gray-800

    /* active tab border */
      {
      border-color: #ffffff;
    }

    body.dark-theme .bg-white {
      background-color: #2d2d2d;
    }

    body.dark-theme .bg-gray-100 {
      background-color: #404040;
    }

    body.dark-theme .hover\:bg-gray-200:hover {
      background-color: #505050;
    }

    body.dark-theme .selected-color-display {
      border-color: #404040;
    }

    body.dark-theme .selected-color-display:hover {
      border-color: #0095f6;
    }


    .theme-switch {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
    }

    .theme-switch-btn {
      background-color: #0095f6;
      color: white;
      border: none;
      border-radius: 8px;
      padding: 8px 16px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: background-color 0.2s ease-in-out;
    }

    .theme-switch-btn:hover {
      background-color: #0081d6;
    }

    /* Style adjustments for a more Instgram-like grid preview */
    #gridContainer {
      /* Use Tailwind gap classes */
      /* gap-1 sm:gap-2 md:gap-4 */
    }

    .grid-cell {
      /* Remove margin, use parent gap */
      margin: 0;
    }
  </style>
</head>

<body class="bg-white font-sans">
  <div class="container mx-auto px-4 py-8 max-w-4xl">

    <!-- ** NEW: Instagram Profile Header Section ** -->
    <section class="profile-header mb-8">
      <div class="flex items-center gap-8 md:gap-16">
        <!-- Profile Picture -->
        <div class="w-20 h-20 md:w-32 md:h-32 flex-shrink-0">
          <img id="profilePic"
            src="https://img.freepik.com/premium-vector/man-avatar-profile-picture-social-media-vector-illustration-eps10_268834-1894.jpg?w=2000"
            alt="Profile Picture" class="w-full h-full rounded-full object-cover border border-gray-300">
        </div>
        <!-- Profile Info (Username, Stats, Bio) -->
        <div class="flex-grow">
          <!-- Username & Buttons -->
          <div class="flex flex-col sm:flex-row sm:items-center gap-2 sm:gap-4 mb-2">
            <h2 id="username" class="text-xl md:text-2xl font-semibold text-gray-800">Media Connect</h2>
            <!-- Optional: Add buttons like "Edit Profile" or "Follow" -->
            <!-- <button class="bg-gray-200 text-gray-800 px-4 py-1 rounded-lg text-sm font-semibold">Edit Profile</button> -->
          </div>
          <!-- Stats (Posts, Followers, Following) -->
          <div class="flex gap-4 md:gap-6 mb-2 text-gray-700 text-sm md:text-base">
            <div>
              <span class="font-bold" id="postCount">0</span> posts
            </div>
            <div>
              <span class="font-bold" id="followerCount">1,234</span> followers
            </div>
            <div>
              <span class="font-bold" id="followingCount">567</span> following
            </div>
          </div>
          <!-- Bio -->
          <p id="bio" class="text-sm text-gray-800">
            Это серфис для проектирования сетки фото сервиса media connect <br> Media connect - сервис для
            профессианалов
          </p>
        </div>
      </div>
    </section>
    <!-- ** END NEW: Instagram Profile Header Section ** -->


    <!-- Editor Controls -->
    <!-- Re-purposing the original header area for editor controls -->
    <div class="flex justify-between items-center mb-6 border-t border-b border-gray-200 py-3">
      <h1 class="text-base font-bold text-gray-800">Grid Editor Controls</h1> <!-- Title adjusted -->
      <div class="flex space-x-4">
        <button id="addRowBtn"
          class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded-lg flex items-center text-xs md:text-sm">
          <i class="fas fa-plus mr-1 md:mr-2"></i> Add Row
        </button>
        <button id="exportBtn"
          class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded-lg flex items-center text-xs md:text-sm">
          <i class="fas fa-download mr-1 md:mr-2"></i> Export JPEG
        </button>
      </div>
    </div>

    <!-- Upload and Color Picker Section -->
    <div class="mb-6 p-4 bg-white rounded-lg border border-gray-200">
      <div class="flex flex-wrap items-center gap-6">
        <!-- Upload Input/Button -->
        <div>
          <label for="imageUpload" class="block text-sm font-medium text-gray-700 mb-2">Upload Images to Grid</label>
          <input type="file" id="imageUpload" accept="image/*" multiple class="hidden">
          <button onclick="document.getElementById('imageUpload').click()" class="upload-button text-sm">
            <i class="fas fa-image"></i>
            <span>Select Files</span>
          </button>
          <div id="uploadProgress" class="hidden w-48">
            <div class="upload-progress">
              <div id="progressBar" class="progress-bar" style="width: 0%"></div>
            </div>
            <p id="uploadStatus" class="upload-status">Processing...</p>
          </div>
        </div>
        <!-- Color Picker -->
        <div class="color-picker-container">
          <label class="block text-sm font-medium text-gray-700 mb-2">Selected Grid Color</label>
          <div class="flex items-center cursor-pointer" onclick="toggleColorPicker()">
            <div id="selectedColorDisplay" class="selected-color-display" style="background-color: #ffffff;"></div>
            <span class="text-sm text-gray-600">Click to change color</span>
          </div>
          <!-- Dropdown remains the same -->
          <div class="color-picker-dropdown">
            <div class="color-palette">
              <div class="color-option bg-red-500" data-color="#ff0000" onclick="selectColor(this)"></div>
              <div class="color-option bg-orange-500" data-color="#ff7f00" onclick="selectColor(this)"></div>
              <div class="color-option bg-yellow-500" data-color="#ffff00" onclick="selectColor(this)"></div>
              <div class="color-option bg-green-500" data-color="#00ff00" onclick="selectColor(this)"></div>
              <div class="color-option bg-blue-500" data-color="#0000ff" onclick="selectColor(this)"></div>
              <div class="color-option bg-purple-500" data-color="#8b00ff" onclick="selectColor(this)"></div>
              <div class="color-option bg-pink-500" data-color="#ff00ff" onclick="selectColor(this)"></div>
              <div class="color-option bg-rose-500" data-color="#ff007f" onclick="selectColor(this)"></div>
              <div class="color-option bg-amber-500" data-color="#ffbf00" onclick="selectColor(this)"></div>
              <div class="color-option bg-lime-500" data-color="#7fff00" onclick="selectColor(this)"></div>
              <div class="color-option bg-emerald-500" data-color="#00ff7f" onclick="selectColor(this)"></div>
              <div class="color-option bg-cyan-500" data-color="#00ffff" onclick="selectColor(this)"></div>
              <div class="color-option bg-sky-500" data-color="#007fff" onclick="selectColor(this)"></div>
              <div class="color-option bg-violet-500" data-color="#7f00ff" onclick="selectColor(this)"></div>
              <div class="color-option bg-fuchsia-500" data-color="#ff007f" onclick="selectColor(this)"></div>
              <div class="color-option bg-gray-500" data-color="#808080" onclick="selectColor(this)"></div>
              <div class="color-option bg-slate-500" data-color="#708090" onclick="selectColor(this)"></div>
              <div class="color-option bg-black" data-color="#000000" onclick="selectColor(this)"></div>
              <div class="color-option bg-white border border-gray-300 active" data-color="#ffffff"
                onclick="selectColor(this)"></div>
            </div>
            <div class="custom-color-section">
              <label for="customColorPicker" class="block text-sm font-medium text-gray-700 mb-2">Custom Color</label>
              <div class="custom-color-trigger">
                <input type="color" id="customColorPicker" class="custom-color-input" value="#ffffff">
                <div class="w-6 h-6 rounded-full border border-gray-300" id="customColorTriggerDisplay"
                  style="background-color: #ffffff;"></div>
                <span>Select Custom Color</span>
              </div>
              <input type="text" id="hexColorInput" class="hex-color-input"
                placeholder="Enter hex color (e.g. #ff0000)">
              <button id="applyCustomColor" class="apply-custom-color">
                Apply Custom Color
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>


    <!-- ** NEW: Tabs Section (Posts, Reels, Tagged) ** -->
    <div class="flex justify-around text-gray-500 text-sm md:text-base mb-1 md:mb-4">
      <!-- "Posts" tab - active -->
      <div
        class="flex items-center py-3 px-6 border-t-2 border-gray-800 -mt-px text-gray-800 font-semibold cursor-pointer">
        <i class="fas fa-th mr-2"></i> Posts
      </div>
      <!-- Other tabs (placeholders as we only have grid functionality) -->
      <div class="flex items-center py-3 px-6 cursor-pointer">
        <i class="fas fa-film mr-2"></i> Reels
      </div>
      <div class="flex items-center py-3 px-6 cursor-pointer">
        <i class="fas fa-user-tag mr-2"></i> Tagged
      </div>
    </div>
    <!-- ** END NEW: Tabs Section ** -->


    <div id="gridContainer" class="grid grid-cols-3 gap-1 md:gap-4 mb-8">
      <!-- Grid cells will be added here -->
    </div>

    <div class="text-center">
      <button id="loadMoreBtn" class="bg-gray-100 hover:bg-gray-200 text-gray-700 px-4 py-2 rounded-lg">
        <i class="fas fa-arrow-down mr-2"></i> Load More
      </button>
    </div>
  </div>

  <!-- Theme Switch Button -->
  <div class="theme-switch">
    <button class="theme-switch-btn" onclick="toggleTheme()">
      <i class="fas fa-moon"></i>
      <span>Dark Mode</span>
    </button>
  </div>

  <script>
    // Initialize the grid
    let gridData = [];
    let draggedCell = null;
    // Initialize with a default selected color (white)
    let selectedColor = '#ffffff';

    // Load saved data from localStorage
    function loadFromStorage() {
      const savedData = localStorage.getItem('instagramGridData');
      if (savedData) {
        gridData = JSON.parse(savedData);
        // Ensure backward compatibility and correct structure
        gridData = gridData.map(cell => {
          // Handle cases where cell might be null or old format
          if (!cell || (typeof cell.content === 'string' && !cell.type)) {
            // Looks like an old image cell
            return {type: 'image', content: cell.content, color: null};
          } else if (typeof cell.content === 'string' && cell.type === 'color') {
            // Looks like a color cell (content IS the color)
            return {type: 'color', content: cell.content, color: null}; // color overlay is not applicable to color cells
          } else if (!cell || (!cell.content && !cell.color && !cell.type)) {
            // Looks like an old empty cell or null
            return {type: 'empty', content: null, color: null};
          }
          // If it already has a type, assume it's correct
          return cell;
        });
        renderGrid();
      } else {
        // Initialize with 3 empty rows if no saved data
        addNewRow();
        addNewRow();
        addNewRow();
      }
      // Set the display for the default selected color
      document.getElementById('selectedColorDisplay').style.backgroundColor = selectedColor;
      // Mark the default color option as active
      const defaultColorOption = document.querySelector('.color-palette .color-option[data-color="#ffffff"]');
      if (defaultColorOption) {
        defaultColorOption.classList.add('active');
      }
      // Set initial custom color picker value
      document.getElementById('customColorPicker').value = selectedColor;
      document.getElementById('hexColorInput').value = selectedColor;
      document.getElementById('customColorTriggerDisplay').style.backgroundColor = selectedColor;
    }

    // Save current grid to localStorage
    function saveToStorage() {
      localStorage.setItem('instagramGridData', JSON.stringify(gridData));
      updatePostCount(); // Update count whenever data changes
    }

    // Add a new row to the grid
    function addNewRow() {
      for (let i = 0; i < 3; i++) {
        gridData.push({type: 'empty', content: null, color: null});
      }
      renderGrid();
      saveToStorage(); // Save after adding
    }

    // Update the displayed post count
    function updatePostCount() {
      const postCount = gridData.filter(cell => cell.type === 'image' || cell.type === 'color').length;
      document.getElementById('postCount').textContent = postCount;
    }

    // Render the entire grid
    function renderGrid() {
      const gridContainer = document.getElementById('gridContainer');
      gridContainer.innerHTML = ''; // Clear existing cells

      gridData.forEach((cell, index) => {
        const cellElement = document.createElement('div');
        cellElement.className = 'grid-cell rounded-lg overflow-hidden relative'; // Base classes
        cellElement.dataset.index = index;

        if (cell.type === 'image') {
          cellElement.innerHTML = `
                        <img src="${cell.content}" class="cell-content" alt="Grid Image">
                        ${cell.color ? `<div class="color-fill-overlay" style="background-color: ${cell.color};"></div>` : ''}
                        <div class="cell-controls">
                             <button class="control-btn" title="Apply selected color overlay" onclick="event.stopPropagation(); applyColorToCell(${index}, selectedColor)">
                                <i class="fas fa-fill-drip"></i>
                            </button>
                             <button class="control-btn" title="Remove color overlay" onclick="event.stopPropagation(); removeColorOverlay(${index})">
                                <i class="fas fa-tint-slash"></i>
                            </button>
                            <button class="control-btn" title="Remove image" onclick="event.stopPropagation(); clearCell(${index})">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    `;
        } else if (cell.type === 'color') {
          cellElement.style.backgroundColor = cell.content; // Use content for the color string
          cellElement.innerHTML = `
                         <!-- No content needed, background color fills it -->
                         <div class="cell-controls">
                              <button class="control-btn" title="Change color" onclick="event.stopPropagation(); applyColorToCell(${index}, selectedColor)">
                                <i class="fas fa-fill-drip"></i>
                            </button>
                            <button class="control-btn" title="Remove color" onclick="event.stopPropagation(); clearCell(${index})">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    `;
        } else { // type is 'empty'
          cellElement.classList.add('empty-cell-bg'); // Add a background class
          cellElement.innerHTML = `
                         <div class="empty-cell-content">
                             <i class="fas fa-image text-2xl mb-2 text-gray-400"></i>
                             <p class="text-gray-500">Empty</p>
                         </div>
                        <div class="cell-controls">
                            <button class="control-btn" title="Fill with selected color" onclick="event.stopPropagation(); applyColorToCell(${index}, selectedColor)">
                                <i class="fas fa-fill-drip"></i>
                            </button>
                            <button class="control-btn" title="Clear cell" onclick="event.stopPropagation(); clearCell(${index})">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    `;
          // Add click handler specifically for empty cells to allow image upload
          cellElement.addEventListener('click', function () {
            // Only trigger image upload if it's currently empty
            if (gridData[index].type === 'empty') {
              const input = document.createElement('input');
              input.type = 'file';
              input.accept = 'image/*';
              input.onchange = (e) => {
                if (e.target.files.length) {
                  handleImageUpload(e.target.files[0], index);
                }
              };
              input.click();
            }
          });
        }


        // Add drag and drop events to ALL cells
        cellElement.draggable = true;
        cellElement.addEventListener('dragstart', handleDragStart);
        cellElement.addEventListener('dragover', handleDragOver);
        cellElement.addEventListener('drop', handleDrop);
        cellElement.addEventListener('dragend', handleDragEnd);


        gridContainer.appendChild(cellElement);
      });

      updatePostCount(); // Ensure count is updated after rendering
    }

    // Handle image upload with cropping for a portrait-like grid view
    function handleImageUpload(file, index) {
      // Show progress indicator
      document.getElementById('uploadProgress').classList.remove('hidden');
      document.getElementById('progressBar').style.width = '0%';
      document.getElementById('uploadStatus').textContent = 'Processing...';

      // Check file size (max 10MB)
      if (file.size > 10 * 1024 * 1024) {
        document.getElementById('uploadStatus').textContent = 'File too large (max 10MB)';
        document.getElementById('progressBar').style.width = '100%';
        setTimeout(() => {
          document.getElementById('uploadProgress').classList.add('hidden');
        }, 3000);
        return;
      }

      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = function () {
          // Create canvas to crop to 9:16 ratio (or similar portrait like 4:5 for variety?)
          // Let's stick to 9:16 as defined by .grid-cell aspect-ratio
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');

          const targetWidth = 1080; // Standard width for Instagram posts
          const targetHeight = 1920; // 1080 * (16/9) = 1920, a common portrait video/reel size, though typical posts are shorter (4:5 = 1080x1350)
          // Let's adjust the target height slightly to 4:5 ratio (1080x1350) as this is more common for grid posts
          // Or maybe stick to 9:16 as per existing CSS? The CSS uses 9/16 ratio, which means Height is GREATER than Width.
          // Okay, let's match the CSS aspect-ratio: width / height = 9 / 16 => height = width * 16 / 9
          // Let's use 1080 as the height for good resolution. Width = 1080 * 9/16 = 607.5. Not standard.
          // Let's use 1080 as the width. Height = 1080 * 16/9 = 1920. This fits the CSS aspect-ratio.
          const canvasWidth = 1080;
          const canvasHeight = 1920; // Matches 9:16 aspect ratio

          let sourceX = 0, sourceY = 0;
          let sourceWidth = img.width, sourceHeight = img.height;

          const sourceRatio = img.width / img.height;
          const targetRatio = canvasWidth / canvasHeight; // This is 9/16

          // Calculate source area to crop to match the 9:16 target ratio
          if (sourceRatio > targetRatio) {
            // Source is wider than 9:16, crop sides
            sourceWidth = img.height * targetRatio;
            sourceX = (img.width - sourceWidth) / 2;
            sourceHeight = img.height; // Keep original height
          } else {
            // Source is taller than 9:16 or same ratio, crop top/bottom
            sourceHeight = img.width / targetRatio;
            sourceY = (img.height - sourceHeight) / 2;
            sourceWidth = img.width; // Keep original width
          }

          canvas.width = canvasWidth;
          canvas.height = canvasHeight;

          // Draw the cropped portion onto the canvas, scaled to target size
          ctx.drawImage(
            img,
            sourceX, sourceY, sourceWidth, sourceHeight, // Source rectangle
            0, 0, canvas.width, canvas.height // Destination rectangle
          );

          // Update progress
          document.getElementById('progressBar').style.width = '50%';
          document.getElementById('uploadStatus').textContent = 'Optimizing image...';

          // Optimize image quality based on file size
          // Use a reasonable quality (0.8-0.9) for grid previews
          const quality = 0.85;
          const croppedImage = canvas.toDataURL('image/jpeg', quality);

          // Check if index is valid
          if (index >= 0 && index < gridData.length) {
            gridData[index] = {
              type: 'image',
              content: croppedImage,
              color: null // Reset color overlay for new image
            };
            renderGrid();
            saveToStorage(); // Save after successful upload

            // Update progress
            document.getElementById('progressBar').style.width = '100%';
            document.getElementById('uploadStatus').textContent = 'Upload complete!';
            setTimeout(() => {
              document.getElementById('uploadProgress').classList.add('hidden');
            }, 2000);
          } else {
            console.error("Attempted to upload image to invalid index:", index);
            document.getElementById('uploadStatus').textContent = 'Error: Invalid cell index';
            setTimeout(() => {
              document.getElementById('uploadProgress').classList.add('hidden');
            }, 3000);
          }
        };
        img.onerror = function () {
          document.getElementById('uploadStatus').textContent = 'Error: Failed to load image';
          setTimeout(() => {
            document.getElementById('uploadProgress').classList.add('hidden');
          }, 3000);
        };
        img.src = e.target.result;
      };
      reader.onerror = function () {
        document.getElementById('uploadStatus').textContent = 'Error: Failed to read file';
        setTimeout(() => {
          document.getElementById('uploadProgress').classList.add('hidden');
        }, 3000);
      };
      reader.readAsDataURL(file);
    }

    // Handle multiple image upload
    document.getElementById('imageUpload').addEventListener('change', (e) => {
      const files = Array.from(e.target.files);
      let emptyCellIndices = gridData
        .map((cell, idx) => cell.type === 'empty' ? idx : -1)
        .filter(idx => idx !== -1);

      // If there aren't enough empty cells, add rows
      if (files.length > emptyCellIndices.length) {
        const neededRows = Math.ceil((files.length - emptyCellIndices.length) / 3);
        for (let i = 0; i < neededRows; i++) {
          addNewRow(); // This also calls renderGrid and saveToStorage
        }
        // Re-calculate empty indices after adding rows and rendering
        emptyCellIndices = gridData
          .map((cell, idx) => cell.type === 'empty' ? idx : -1)
          .filter(idx => idx !== -1);
      }

      // Process files sequentially to avoid overwhelming the browser
      let currentIndex = 0;
      const processNextFile = () => {
        if (currentIndex < files.length && currentIndex < emptyCellIndices.length) {
          // Delay processing slightly to show individual upload progress
          setTimeout(() => {
            handleImageUpload(files[currentIndex], emptyCellIndices[currentIndex]);
            currentIndex++;
            processNextFile(); // Process the next file
          }, 200); // Small delay between uploads
        } else {
          // All files scheduled, hide progress after a final delay
          setTimeout(() => {
            document.getElementById('uploadProgress').classList.add('hidden');
          }, 2000); // Keep "Upload complete!" visible for a moment
        }
      };

      // Start processing the first file immediately or after a short delay
      if (files.length > 0 && emptyCellIndices.length > 0) {
        document.getElementById('uploadProgress').classList.remove('hidden');
        document.getElementById('progressBar').style.width = '0%';
        document.getElementById('uploadStatus').textContent = `Uploading ${files.length} files...`;
        processNextFile();
      }


      // Reset input so same files can be selected again if needed
      e.target.value = '';
    });


    // Color picker toggle function
    function toggleColorPicker() {
      const container = document.querySelector('.color-picker-container');
      container.classList.toggle('active');
    }

    // Close color picker when clicking outside
    document.addEventListener('click', function (event) {
      const colorPicker = document.querySelector('.color-picker-container');
      if (!colorPicker.contains(event.target)) {
        colorPicker.classList.remove('active');
      }
    });

    // Color selection functions
    function selectColor(element) {
      // Remove active class from all color options
      document.querySelectorAll('.color-palette .color-option').forEach(opt => {
        opt.classList.remove('active');
      });

      // Add active class to selected color
      element.classList.add('active');

      // Get the color from data attribute or background
      const color = element.dataset.color || element.style.backgroundColor; // data-color is preferred

      selectedColor = color;

      // Update selected color display and custom picker inputs
      document.getElementById('selectedColorDisplay').style.backgroundColor = selectedColor;
      document.getElementById('customColorPicker').value = hexToRgb(selectedColor) ? rgbToHex(hexToRgb(selectedColor)) : selectedColor; // Ensure hex format
      document.getElementById('hexColorInput').value = hexToRgb(selectedColor) ? rgbToHex(hexToRgb(selectedColor)) : selectedColor;
      document.getElementById('customColorTriggerDisplay').style.backgroundColor = selectedColor;

      // Close the dropdown
      document.querySelector('.color-picker-container').classList.remove('active');
    }

    // Helper to convert RGB(a) string to Hex (needed because element.style.backgroundColor might return rgb)
    function rgbToHex(rgb) {
      // Handle rgba
      if (rgb.startsWith('rgba')) {
        const parts = rgb.match(/^rgba\((\d+),\s*(\d+),\s*(\d+),\s*(\d?\.?\d+)\)$/);
        if (parts && parts.length >= 4) {
          return "#" +
            ("0" + parseInt(parts[1], 10).toString(16)).slice(-2) +
            ("0" + parseInt(parts[2], 10).toString(16)).slice(-2) +
            ("0" + parseInt(parts[3], 10).toString(16)).slice(-2);
        }
      }
      // Handle rgb
      const parts = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
      if (parts && parts.length >= 4) {
        return "#" +
          ("0" + parseInt(parts[1], 10).toString(16)).slice(-2) +
          ("0" + parseInt(parts[2], 10).toString(16)).slice(-2) +
          ("0" + parseInt(parts[3], 10).toString(16)).slice(-2);
      }
      return rgb; // Return original if parsing failed (might be hex already)
    }

    // Helper to check if a string is a valid RGB or RGBA color string
    function hexToRgb(hex) {
      // Check for hex format first
      if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
        return hex; // Keep hex as is, conversion not needed for its check
      }
      // Check for rgb/rgba format
      const rgbRegex = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/;
      const rgbaRegex = /^rgba\((\d+),\s*(\d+),\s*(\d+),\s*(\d?\.?\d+)\)$/;
      if (rgbRegex.test(hex) || rgbaRegex.test(hex)) {
        return hex; // It's an rgb/rgba string
      }
      return null; // Not a recognized color string format
    }


    // Apply custom color from color picker input
    document.getElementById('applyCustomColor').addEventListener('click', () => {
      const customColorInput = document.getElementById('customColorPicker');
      const hexInput = document.getElementById('hexColorInput');
      let colorToApply = hexInput.value.trim() || customColorInput.value;

      // Validate hex input if used
      if (hexInput.value.trim() && !/^#([A-Fa-f0-9]{3}){1,2}$/.test(colorToApply)) {
        alert('Invalid hex color format. Please use #RRGGBB.');
        return;
      }

      // Remove active class from predefined color options
      document.querySelectorAll('.color-palette .color-option').forEach(opt => {
        opt.classList.remove('active');
      });

      selectedColor = colorToApply;
      document.getElementById('selectedColorDisplay').style.backgroundColor = selectedColor;
      document.getElementById('customColorTriggerDisplay').style.backgroundColor = selectedColor;
      // Ensure hex input is updated correctly if color picker was used
      document.getElementById('hexColorInput').value = hexToRgb(selectedColor) ? rgbToHex(hexToRgb(selectedColor)) : selectedColor;

      // Close the dropdown
      document.querySelector('.color-picker-container').classList.remove('active');
    });

    // Make the custom color trigger div open the color picker
    document.querySelector('.custom-color-trigger').addEventListener('click', function () {
      document.getElementById('customColorPicker').click(); // Trigger the actual color picker input
    });


    // Function to apply color to a specific cell index
    function applyColorToCell(index, color) {
      if (index >= 0 && index < gridData.length) {
        const cell = gridData[index];
        if (cell.type === 'image') {
          // Apply as overlay to image
          cell.color = color;
        } else { // type is 'empty' or 'color'
          // Change type to color fill
          gridData[index] = {type: 'color', content: color, color: null}; // content holds the color string
        }
        renderGrid();
        saveToStorage();
      } else {
        console.error("Attempted to apply color to invalid index:", index);
      }
    }

    // Function to remove color overlay from an image cell
    function removeColorOverlay(index) {
      if (index >= 0 && index < gridData.length && gridData[index].type === 'image') {
        gridData[index].color = null;
        renderGrid();
        saveToStorage();
      }
    }


    // Clear a cell (makes it empty)
    function clearCell(index) {
      if (index >= 0 && index < gridData.length) {
        gridData[index] = {type: 'empty', content: null, color: null};
        renderGrid();
        saveToStorage();
      } else {
        console.error("Attempted to clear invalid index:", index);
      }
    }

    // Drag and drop functions
    function handleDragStart(e) {
      draggedCell = this;
      this.classList.add('dragging');
      e.dataTransfer.setData('text/plain', this.dataset.index);
      e.dataTransfer.effectAllowed = 'move';
      // Add a timeout to allow the ghost image to be created before hiding the original
      setTimeout(() => {
        this.style.opacity = '0'; // Hide the original element visually, keep its space
      }, 0);
    }

    function handleDragOver(e) {
      e.preventDefault(); // Necessary to allow dropping
      e.dataTransfer.dropEffect = 'move';
      // Optional: Add visual indicator to drop target
      const targetCell = e.target.closest('.grid-cell');
      if (targetCell && targetCell !== draggedCell) {
        // Remove from previous
        document.querySelectorAll('.grid-cell.drag-over').forEach(cell => cell.classList.remove('drag-over'));
        // Add to current target
        targetCell.classList.add('drag-over');
      }
    }

    function handleDrop(e) {
      e.preventDefault();
      // Remove visual indicator
      document.querySelectorAll('.grid-cell.drag-over').forEach(cell => cell.classList.remove('drag-over'));

      const sourceIndex = parseInt(e.dataTransfer.getData('text/plain'));
      const targetCell = e.target.closest('.grid-cell');

      if (!targetCell) return; // Not dropped on a grid cell

      const targetIndex = parseInt(targetCell.dataset.index);

      if (sourceIndex !== targetIndex && sourceIndex >= 0 && targetIndex >= 0 && sourceIndex < gridData.length && targetIndex < gridData.length) {
        // Swap the cells data in the array
        const temp = gridData[sourceIndex];
        gridData[sourceIndex] = gridData[targetIndex];
        gridData[targetIndex] = temp;

        renderGrid(); // Re-render the grid
        saveToStorage(); // Save the new order
      }
    }

    function handleDragEnd() {
      this.classList.remove('dragging');
      // Make the original element visible again after the drag finishes
      if (draggedCell) {
        draggedCell.style.opacity = ''; // Restore opacity
        draggedCell.classList.remove('dragging'); // Clean up class
      }
      draggedCell = null;
      // Remove drag-over class from all cells (in case drop didn't happen on a cell)
      document.querySelectorAll('.grid-cell.drag-over').forEach(cell => cell.classList.remove('drag-over'));
    }

    // Export grid as JPEG
    document.getElementById('exportBtn').addEventListener('click', () => {
      // Filter cells that are either images (with or without overlay) or solid colors
      const cellsToExport = gridData.filter(cell => cell.type === 'image' || cell.type === 'color');

      if (cellsToExport.length === 0) {
        alert('Add images or colored cells to export!');
        return;
      }

      // Take cells up to the last full or partial row visible (or just take all)
      // Let's take all for simplicity, or perhaps limit to a typical export size like 9 or 12
      // Instagram profile grid shows up to 12-15 posts initially. Let's take up to 12.
      const items = cellsToExport.slice(0, 12);


      // Create a canvas for the grid
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      // Target dimensions for each cell thumbnail in the export (usually 1:1 on profile grid)
      // Since our cells are 9:16, exporting them as 1:1 thumbnails requires a different cropping/scaling logic.
      // A simpler approach is to render the 9:16 cell content *within* a square space, centered.
      // Or, we could re-crop/scale to 1:1 for the export thumbnail. Let's do the latter for a more accurate grid preview look.
      const cellExportSize = 360; // px for thumbnail size (results in 1080x1080 or 1080x1440 grid)

      // Calculate canvas size based on number of items (3 columns)
      const cols = 3;
      const rows = Math.ceil(items.length / cols);

      canvas.width = cols * cellExportSize;
      canvas.height = rows * cellExportSize;

      // Draw white background
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Load and draw each item (image or color) into its square cell
      let itemsProcessed = 0; // Counter for both images and colors
      const totalItems = items.length;


      if (totalItems === 0) {
        // Should not happen based on the check above, but safety
        return;
      }

      items.forEach((item, index) => {
        const col = index % cols;
        const row = Math.floor(index / cols);
        const x = col * cellExportSize;
        const y = row * cellExportSize;

        if (item.type === 'color') {
          ctx.fillStyle = item.content;
          ctx.fillRect(x, y, cellExportSize, cellExportSize);
          itemsProcessed++;
          if (itemsProcessed === totalItems) {
            exportCanvas(canvas);
          }
        } else if (item.type === 'image') {
          const img = new Image();
          img.onload = function () {
            // Draw image cropped/scaled to fit the square export cell
            const sourceImg = new Image(); // Use a new image element to avoid modifying the one used for grid display
            sourceImg.onload = function () {
              const sourceWidth = sourceImg.width;
              const sourceHeight = sourceImg.height;
              const sourceRatio = sourceWidth / sourceHeight;
              const targetRatio = 1; // 1:1 square

              let cropX = 0, cropY = 0;
              let cropWidth = sourceWidth, cropHeight = sourceHeight;

              if (sourceRatio > targetRatio) {
                // Source is wider than 1:1, crop sides
                cropWidth = sourceHeight * targetRatio;
                cropX = (sourceWidth - cropWidth) / 2;
              } else {
                // Source is taller than 1:1 or same ratio, crop top/bottom
                cropHeight = sourceWidth / targetRatio;
                cropY = (sourceHeight - cropHeight) / 2;
              }

              // Draw the cropped portion onto the export canvas cell
              ctx.drawImage(
                sourceImg,
                cropX, cropY, cropWidth, cropHeight, // Source rectangle (cropped)
                x, y, cellExportSize, cellExportSize // Destination rectangle (square cell)
              );

              // Apply color overlay if exists
              if (item.color) {
                ctx.save();
                ctx.globalCompositeOperation = 'multiply';
                ctx.fillStyle = item.color;
                ctx.fillRect(x, y, cellExportSize, cellExportSize);
                ctx.restore();
              }

              itemsProcessed++;
              if (itemsProcessed === totalItems) {
                exportCanvas(canvas);
              }
            }
            // Use the original image source for re-drawing
            sourceImg.src = item.content;
          };
          img.onerror = function () {
            console.error("Failed to load image for export:", item.content);
            itemsProcessed++; // Still increment counter to allow export to proceed
            if (itemsProcessed === totalItems) {
              exportCanvas(canvas);
            }
          };
          // We load the image once here just to get its original dimensions
          img.src = item.content;
        }
      });
    });

    // Helper function to trigger the download
    function exportCanvas(canvas) {
      const dataURL = canvas.toDataURL('image/jpeg', 0.95); // Use higher quality for final export
      const link = document.createElement('a');
      link.download = 'instagram-grid.jpg';
      link.href = dataURL;
      link.click();
    }


    // Button event listeners
    document.getElementById('addRowBtn').addEventListener('click', addNewRow);
    document.getElementById('loadMoreBtn').addEventListener('click', addNewRow);

    // Keep color picker dropdown open when interacting inside it
    const colorPickerContainer = document.querySelector('.color-picker-container');
    const colorPickerDropdown = document.querySelector('.color-picker-dropdown');

    if (colorPickerDropdown && colorPickerContainer) {
      colorPickerDropdown.addEventListener('mouseenter', () => {
        colorPickerContainer.classList.add('active');
      });
      colorPickerDropdown.addEventListener('mouseleave', () => {
        // Add a small delay to allow clicking on elements inside the dropdown
        setTimeout(() => {
          // Check if mouse is still inside the container before closing
          if (!colorPickerContainer.matches(':hover')) {
            colorPickerContainer.classList.remove('active');
          }
        }, 100); // Adjust delay if needed
      });
      // Also close if the trigger itself is clicked while open
      document.getElementById('selectedColorDisplay').addEventListener('click', () => {
        colorPickerContainer.classList.remove('active');
      });
    }


    // Theme switching
    function toggleTheme() {
      document.body.classList.toggle('dark-theme');
      const isDark = document.body.classList.contains('dark-theme');
      localStorage.setItem('theme', isDark ? 'dark' : 'light');

      const themeBtn = document.querySelector('.theme-switch-btn');
      themeBtn.innerHTML = isDark
        ? '<i class="fas fa-sun"></i><span>Light Mode</span>'
        : '<i class="fas fa-moon"></i><span>Dark Mode</span>';
    }

    // Load saved theme
    function loadTheme() {
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme === 'dark') {
        document.body.classList.add('dark-theme');
        const themeBtn = document.querySelector('.theme-switch-btn');
        themeBtn.innerHTML = '<i class="fas fa-sun"></i><span>Light Mode</span>';
      }
    }

    // Hex color input handling
    document.getElementById('hexColorInput').addEventListener('input', function (e) {
      const hexColor = e.target.value.trim();
      // Simple validation for hex format
      if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hexColor)) {
        document.getElementById('customColorPicker').value = hexColor;
        document.getElementById('customColorTriggerDisplay').style.backgroundColor = hexColor;
        // We don't automatically selectColor here, only on "Apply"
      } else {
        // Optionally indicate invalid input visually
      }
    });

    // Update hex input and trigger display when color picker changes
    document.getElementById('customColorPicker').addEventListener('input', function (e) {
      const color = e.target.value;
      document.getElementById('hexColorInput').value = color;
      document.getElementById('customColorTriggerDisplay').style.backgroundColor = color;
      // We don't automatically selectColor here, only on "Apply"
    });


    // Initialize theme and load grid data on page load
    document.addEventListener('DOMContentLoaded', function () {
      loadTheme();
      loadFromStorage();
    });
  </script>
</body>

</html>
